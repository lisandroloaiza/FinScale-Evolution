# Data Governance - Gesti√≥n de Datos Corporativa

> **Objetivo**: Establecer pol√≠ticas de calidad, seguridad y lifecycle de datos  
> **Alcance**: Todos los datos de FinScale (transaccional, anal√≠tico, PII)

---

## üéØ Principios de Data Governance

1. **Data as an Asset**: Los datos son un activo estrat√©gico
2. **Privacy by Design**: GDPR compliance desde el dise√±o
3. **Single Source of Truth**: Event Sourcing como fuente can√≥nica
4. **Data Quality**: Validaci√≥n en origen + monitoring continuo
5. **Access Control**: Least privilege + audit trail

---

## üìä Data Classification

### Niveles de Sensibilidad

| Nivel | Tipo de Dato | Ejemplos | Retention | Encryption |
|-------|--------------|----------|-----------|------------|
| **PUBLIC** | No sensible | Tipos de cambio, FAQs | Indefinido | No requerido |
| **INTERNAL** | Uso interno | Logs de sistema, m√©tricas | 90 d√≠as | At-rest |
| **CONFIDENTIAL** | Datos de negocio | Transacciones, saldos | 7 a√±os | At-rest + in-transit |
| **RESTRICTED** | PII, PCI-DSS | Nombres, cuentas bancarias, CVV | Variable | At-rest + in-transit + tokenization |

---

### Personal Identifiable Information (PII)

**Inventario de PII**:

```yaml
Customer Service:
  PII Fields:
    - customer.full_name           # RESTRICTED
    - customer.email               # RESTRICTED
    - customer.phone_number        # RESTRICTED
    - customer.date_of_birth       # RESTRICTED
    - customer.national_id         # RESTRICTED (encrypted)
    - customer.address             # CONFIDENTIAL
  
  Retention:
    Active: Indefinido
    Inactive (no transactions 5 a√±os): Anonimizar
    Upon request (GDPR Art. 17): Delete within 30 d√≠as

Payment Service:
  PII Fields:
    - beneficiary.name             # CONFIDENTIAL
    - beneficiary.account_number   # RESTRICTED (tokenized)
    - beneficiary.bank_code        # PUBLIC
  
  Retention:
    Legal requirement: 7 a√±os (anti-money laundering)
    Post-deletion: Anonimizar (replace with "DELETED_USER_XXX")
```

---

## üîê Data Protection

### Encryption Strategy

```yaml
At Rest:
  Database: AWS RDS with KMS encryption
    Algorithm: AES-256
    Key Rotation: Autom√°tica (365 d√≠as)
  
  Object Storage (S3): Server-side encryption
    Algorithm: AES-256
    Key Management: AWS KMS
  
  Backups: Encrypted snapshots
    Retention: 30 d√≠as (operational) + 6 meses (compliance)

In Transit:
  External APIs: TLS 1.3
  Internal (service-to-service): mTLS (Istio)
  Database connections: SSL/TLS enforced

At Use:
  Field-level encryption:
    - national_id: Encrypted with customer-specific key
    - account_number: Tokenized (no reversal possible)
```

**Ejemplo de Field-Level Encryption**:

```java
@Service
public class CustomerService {
    
    private final EncryptionService encryptionService;
    
    public Mono<Customer> createCustomer(CreateCustomerRequest request) {
        return Mono.just(request)
            .map(req -> {
                // Generar key espec√≠fica para este customer
                String encryptionKey = encryptionService.generateKey();
                
                // Encriptar PII
                String encryptedNationalId = encryptionService.encrypt(
                    req.getNationalId(), 
                    encryptionKey
                );
                
                return Customer.builder()
                    .id(UUID.randomUUID())
                    .fullName(req.getFullName())  // Plain (para b√∫squedas)
                    .nationalId(encryptedNationalId)  // Encrypted
                    .encryptionKeyId(encryptionKey)
                    .build();
            })
            .flatMap(customerRepository::save);
    }
    
    // GDPR Right to Erasure via Crypto-Shredding
    public Mono<Void> deleteCustomer(String customerId) {
        return customerRepository.findById(customerId)
            .flatMap(customer -> {
                // 1. Delete encryption key (hace datos ilegibles)
                return encryptionService.deleteKey(customer.getEncryptionKeyId())
                    .then(
                        // 2. Anonimizar registros
                        customerRepository.anonymize(customerId)
                    );
            });
    }
}
```

---

### Tokenization (PCI-DSS)

```yaml
Payment Card Data:
  Scope: Card numbers, CVV
  
  Flow:
    1. Client ‚Üí Tokenization Service (external: Stripe, Adyen)
    2. Token ‚Üí FinScale Payment Service
    3. FinScale almacena solo token (no PAN)
  
  Example:
    Real Card: 4532-1234-5678-9010
    Token: tok_1A2B3C4D5E6F7G8H
    
  Benefits:
    - PCI-DSS scope reducido (no almacenamos PAN)
    - De-tokenization solo en Clearing Service (payment execution)
```

---

## üìê Data Quality

### Quality Dimensions

```yaml
Accuracy:
  Definition: Dato correcto seg√∫n fuente real
  Example: Tipo de cambio debe coincidir con Bloomberg
  Validation:
    - Cross-check con fuentes externas
    - Automated reconciliation diaria
  Target: 99.99% accuracy

Completeness:
  Definition: No campos obligatorios nulos
  Example: Payment sin beneficiary.account_number ‚Üí INVALID
  Validation:
    - Schema validation (OpenAPI)
    - Database NOT NULL constraints
  Target: 100% (hard requirement)

Consistency:
  Definition: Mismo dato en todos los servicios
  Example: Customer.email igual en Customer Service y Payment Service
  Validation:
    - Event-driven sync (Kafka)
    - Periodic reconciliation jobs
  Target: 99.9% (eventual consistency lag < 5s)

Timeliness:
  Definition: Dato actualizado
  Example: FX rates < 10s antiguos
  Validation:
    - TTL en cache (Redis)
    - Timestamp en eventos
  Target: 95% de datos < 1 min antiguos
```

### Data Quality Monitoring

```sql
-- Query diaria de Data Quality
SELECT 
    'Payments sin beneficiary' as issue,
    COUNT(*) as count
FROM payments 
WHERE beneficiary_account IS NULL 
  AND created_at >= CURRENT_DATE
UNION ALL
SELECT 
    'Customers sin email' as issue,
    COUNT(*) as count
FROM customers 
WHERE email IS NULL 
  AND created_at >= CURRENT_DATE
UNION ALL
SELECT 
    'FX rates desactualizados' as issue,
    COUNT(*) as count
FROM fx_rates 
WHERE updated_at < (NOW() - INTERVAL '1 minute');

-- Alert si count > 0
```

---

## üîç Data Lineage

### Event Sourcing como Source of Truth

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PaymentCreated    ‚îÇ ‚Üê Evento origen (Kafka)
‚îÇ (Event Store)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ                 ‚îÇ
          ‚ñº                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PostgreSQL      ‚îÇ ‚îÇ Elasticsearch   ‚îÇ
‚îÇ (Write Model)   ‚îÇ ‚îÇ (Read Model)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                 ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚ñº
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ Data Warehouse  ‚îÇ
          ‚îÇ (Snowflake)     ‚îÇ
          ‚îÇ - Analytics     ‚îÇ
          ‚îÇ - BI reports    ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Beneficios**:
- **Trazabilidad completa**: Payment ID ‚Üí todos sus eventos ‚Üí proyecciones
- **Time-travel**: Reconstruir estado a cualquier fecha
- **Auditor√≠a**: Compliance con regulaci√≥n (7 a√±os de hist√≥rico)

---

### Lineage Tracking con OpenLineage

```java
@Component
public class DataLineageTracker {
    
    private final LineageClient lineageClient;
    
    public void trackPaymentCreation(PaymentCreated event) {
        // Registrar lineage
        lineageClient.emit(RunEvent.of(
            RunState.COMPLETE,
            Job.of("payment-service", "createPayment"),
            Run.of(UUID.randomUUID()),
            List.of(
                // Input
                Dataset.of("kafka", "payment-events")
            ),
            List.of(
                // Outputs
                Dataset.of("postgresql", "payments"),
                Dataset.of("elasticsearch", "payments-index")
            )
        ));
    }
}
```

---

## üóÑÔ∏è Data Retention & Archival

### Retention Policies

| Data Type | Active Storage | Archival (Cold) | Deletion |
|-----------|----------------|-----------------|----------|
| **Payment transactions** | 1 a√±o (PostgreSQL) | 6 a√±os (S3 Glacier) | 7 a√±os (legal) |
| **Ledger events (TimescaleDB)** | Infinito comprimido | - | Never (Event Sourcing) |
| **FX rates (Cassandra)** | 10 minutos (TTL) | - | Auto-delete (TTL) |
| **FX locks (Cassandra)** | 5 minutos (TTL) | - | Auto-delete (TTL) |
| **Customer data** | Mientras activo | - | 5 a√±os inactividad o GDPR request |
| **Logs** | 30 d√≠as (hot) | 1 a√±o (cold S3) | 1 a√±o |
| **Metrics (Prometheus)** | 15 d√≠as | 1 a√±o (VictoriaMetrics) | 1 a√±o |

---

### TimescaleDB Event Sourcing Policies

**WHY TimescaleDB**: Ledger Service requiere Event Sourcing inmutable + compresi√≥n nativa + queries anal√≠ticas eficientes

**Configuraci√≥n Hypertables**:

```sql
-- Crear hypertable para ledger events
CREATE TABLE ledger_events (
    event_id UUID PRIMARY KEY,
    aggregate_id UUID NOT NULL,  -- account_id
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    sequence_number BIGINT NOT NULL,
    metadata JSONB
);

SELECT create_hypertable('ledger_events', 'timestamp', 
    chunk_time_interval => INTERVAL '1 month'
);

-- Immutability constraint
CREATE OR REPLACE FUNCTION prevent_update_delete()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Event Sourcing: Updates and deletes are not allowed';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER immutable_events
BEFORE UPDATE OR DELETE ON ledger_events
FOR EACH ROW EXECUTE FUNCTION prevent_update_delete();
```

**Compression Policy** (10x reduction):

```sql
-- Comprimir chunks despu√©s de 30 d√≠as
ALTER TABLE ledger_events SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'aggregate_id, event_type',
    timescaledb.compress_orderby = 'timestamp DESC'
);

SELECT add_compression_policy('ledger_events', INTERVAL '30 days');

-- Resultado: 1 TB raw ‚Üí 100 GB compressed
```

**GDPR Compliance con Crypto-Shredding**:

**Problema**: Event Sourcing es inmutable, pero GDPR Right to Erasure (Art. 17) requiere borrar PII

**Soluci√≥n**: Encriptar PII con customer-specific key, borrar key = erasure

```sql
-- Event con PII encriptado
INSERT INTO ledger_events VALUES (
    gen_random_uuid(),
    '123e4567-e89b-12d3-a456-426614174000',  -- aggregate_id
    'AccountOpened',
    jsonb_build_object(
        'account_number', encrypt_pii('0001234567', customer_key),  -- Encrypted
        'account_type', 'CHECKING',
        'initial_balance', 1000.00
    ),
    NOW(),
    1,
    jsonb_build_object('customer_key_id', 'key-abc-123')
);

-- GDPR erasure: borrar customer key
DELETE FROM encryption_keys WHERE key_id = 'key-abc-123';

-- Resultado: PII en eventos es ahora ilegible (compliant)
```

**Continuous Aggregates** (queries r√°pidas):

```sql
-- Materializar balance por cuenta
CREATE MATERIALIZED VIEW account_balance
WITH (timescaledb.continuous) AS
SELECT 
    aggregate_id as account_id,
    time_bucket('1 day', timestamp) AS day,
    SUM(CASE WHEN event_type = 'MoneyDeposited' 
             THEN (event_data->>'amount')::numeric 
             ELSE 0 END) as total_deposits,
    SUM(CASE WHEN event_type = 'MoneyWithdrawn' 
             THEN (event_data->>'amount')::numeric 
             ELSE 0 END) as total_withdrawals
FROM ledger_events
GROUP BY aggregate_id, time_bucket('1 day', timestamp);

-- Refresh autom√°tico cada 1 hora
SELECT add_continuous_aggregate_policy('account_balance',
    start_offset => INTERVAL '3 months',
    end_offset => INTERVAL '1 hour',
    schedule_interval => INTERVAL '1 hour'
);
```

---

### Cassandra TTL Automation

**WHY Cassandra**: FX Service necesita 100K writes/s con TTL nativo para auto-cleanup

**FX Rates Table** (10-minute TTL):

```cql
CREATE TABLE fx_rates (
    currency_pair TEXT,        -- USD/BRL
    timestamp TIMESTAMP,       -- Quote time
    bid_price DECIMAL,
    ask_price DECIMAL,
    source TEXT,               -- Bloomberg, Reuters
    PRIMARY KEY (currency_pair, timestamp)
) WITH CLUSTERING ORDER BY (timestamp DESC)
  AND default_time_to_live = 600;  -- 10 minutos TTL

-- Insert con TTL expl√≠cito si needed
INSERT INTO fx_rates (currency_pair, timestamp, bid_price, ask_price, source)
VALUES ('USD/BRL', toTimestamp(now()), 5.0234, 5.0456, 'Bloomberg')
USING TTL 600;  -- Auto-delete after 10 minutos
```

**FX Locks Table** (5-minute TTL):

```cql
CREATE TABLE fx_locks (
    payment_id UUID,
    currency_pair TEXT,
    locked_rate DECIMAL,
    expires_at TIMESTAMP,
    PRIMARY KEY (payment_id)
) WITH default_time_to_live = 300;  -- 5 minutos TTL

-- Use case: Payment locks FX rate for 5 minutos
-- Si payment no ejecuta en 5 min, lock auto-expira
```

**Compaction Strategy**:

```cql
-- Time-Window Compaction (optimizado para TTL)
ALTER TABLE fx_rates WITH compaction = {
    'class': 'TimeWindowCompactionStrategy',
    'compaction_window_unit': 'HOURS',
    'compaction_window_size': 1
};

-- Resultado: TTL expired data elimina r√°pido sin tombstones
```

**Monitoring TTL Expiration**:

```promql
# Prometheus metrics
cassandra_table_live_disk_space_used{table="fx_rates"}
cassandra_table_tombstone_count{table="fx_rates"}

# Alert si tombstones > 10K (TTL no funciona bien)
```

### Archival Process

```yaml
# Kubernetes CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: payment-archival
spec:
  schedule: "0 2 * * 0"  # Domingo 02:00 UTC
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: archival
            image: finscale/data-archival:latest
            command:
            - python
            - /app/archive.py
            env:
            - name: ARCHIVAL_AGE_DAYS
              value: "365"
            - name: S3_BUCKET
              value: "finscale-archive-cold"
```

**Script de Archival**:

```python
# archive.py
import psycopg2
import boto3
from datetime import datetime, timedelta

def archive_old_payments():
    cutoff_date = datetime.now() - timedelta(days=365)
    
    # 1. Export a S3 (formato Parquet)
    conn = psycopg2.connect(DB_URL)
    cursor = conn.cursor()
    cursor.execute("""
        COPY (
            SELECT * FROM payments 
            WHERE created_at < %s
        ) TO STDOUT WITH (FORMAT parquet)
    """, (cutoff_date,))
    
    s3_client = boto3.client('s3')
    s3_client.upload_fileobj(
        cursor, 
        'finscale-archive-cold', 
        f'payments/{cutoff_date.year}/payments.parquet'
    )
    
    # 2. Delete de PostgreSQL
    cursor.execute("""
        DELETE FROM payments 
        WHERE created_at < %s
    """, (cutoff_date,))
    conn.commit()
    
    print(f"Archived payments older than {cutoff_date}")
```

---

## üë• Data Access Control

### Role-Based Access Control (RBAC)

```yaml
Roles:
  DataEngineer:
    Permissions:
      - READ: all_databases
      - WRITE: staging_databases
      - EXECUTE: ETL pipelines
    
  DataAnalyst:
    Permissions:
      - READ: data_warehouse (Snowflake)
      - READ: elasticsearch (read models)
      - NO WRITE
  
  DBA:
    Permissions:
      - READ/WRITE: all_databases
      - ADMIN: backup, restore
  
  Developer:
    Permissions:
      - READ: development_databases
      - WRITE: development_databases
      - NO ACCESS: production PII
  
  ComplianceOfficer:
    Permissions:
      - READ: audit_logs
      - READ: all_databases (PII masked)
```

### Data Masking

```sql
-- View para analistas (PII masked)
CREATE VIEW payments_masked AS
SELECT 
    id,
    originator_id,
    -- Mask beneficiary name
    CONCAT(
        LEFT(beneficiary_name, 1), 
        REPEAT('*', LENGTH(beneficiary_name) - 2),
        RIGHT(beneficiary_name, 1)
    ) as beneficiary_name,
    -- Mask account number (show last 4 digits)
    CONCAT('****', RIGHT(beneficiary_account, 4)) as beneficiary_account,
    amount,
    currency,
    status,
    created_at
FROM payments;

-- Grant access
GRANT SELECT ON payments_masked TO data_analyst_role;
```

---

## üìà Data Governance Metrics

```yaml
KPIs:
  Data Quality Score:
    Formula: (accurate_records / total_records) √ó 100
    Target: > 99.9%
  
  GDPR Compliance:
    Metric: Deletion requests completed < 30 d√≠as
    Target: 100%
  
  Data Breach Incidents:
    Metric: Count of incidents
    Target: 0
  
  Encryption Coverage:
    Formula: (encrypted_pii_fields / total_pii_fields) √ó 100
    Target: 100%
  
  Lineage Coverage:
    Formula: (tracked_datasets / total_datasets) √ó 100
    Target: > 90%
```

---

**Pr√≥ximo Paso**: ‚Üí `5.4-Estrategia-Equipos.md`

---

**√öltima actualizaci√≥n**: 7 de diciembre de 2025
