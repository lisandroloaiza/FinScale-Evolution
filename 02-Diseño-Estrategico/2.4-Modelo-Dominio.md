# 2.4 Modelo de Dominio Detallado

> **Objetivo**: DiseÃ±ar el modelo de dominio rico con agregados, entidades y value objects por bounded context identificado en 2.2.  
> **TÃ©cnica**: Domain-Driven Design - Tactical Patterns  
> **AlineaciÃ³n**: Kata FinScale Evolution - 10 Bounded Contexts

---

## ðŸŽ¯ Patrones TÃ¡cticos DDD Aplicados

| PatrÃ³n | DescripciÃ³n | Uso en FinScale |
|--------|-------------|-----------------|
| **Entity** | Objeto con identidad Ãºnica que persiste | Customer, PaymentOrder, LedgerEntry |
| **Value Object** | Objeto inmutable definido por sus atributos | Money, Address, IBAN |
| **Aggregate** | Cluster de objetos tratados como unidad | PaymentOrder + PaymentItems |
| **Aggregate Root** | Punto de entrada al agregado | PaymentOrder (no se accede directamente a PaymentItem) |
| **Domain Event** | Hecho significativo del dominio | PaymentExecuted, FraudDetected |
| **Repository** | AbstracciÃ³n de persistencia | PaymentRepository, CustomerRepository |
| **Domain Service** | LÃ³gica que no pertenece a una entidad | FraudScoringService, FXPricingService |

---

## ðŸ“Š Modelo de Dominio: Vista General

### Agregados, Entidades y Value Objects por Bounded Context

```mermaid
---
config:
  layout: elk
---
classDiagram
direction BT
    class PaymentOrder {
	    -orderId: PaymentOrderId
	    -originator: CustomerId
	    -beneficiary: BeneficiaryInfo
	    -amount: Money
	    -status: PaymentStatus
	    -fxLockId: FXLockId
	    +execute()
	    +validate()
	    +settle()
	    +cancel()
    }

    class PaymentItem {
	    -itemId: String
	    -amount: Money
	    -description: String
    }

    class Money {
	    -amount: BigDecimal
	    -currency: Currency
	    +add(Money) Money
	    +subtract(Money) Money
	    +equals(Object) boolean
    }

    class BeneficiaryInfo {
	    -beneficiaryId: String
	    -accountIdentifier: AccountIdentifier
	    -bankCode: BIC
	    -name: String
	    -country: CountryCode
    }

    class AccountIdentifier {
	    -type: IdentifierType
	    -value: String
	    +validate() boolean
    }

    class LedgerEntry {
	    -entryId: LedgerEntryId
	    -transactionId: TransactionId
	    -debitAccount: AccountId
	    -creditAccount: AccountId
	    -amount: Money
	    -timestamp: Instant
    }

    class Account {
	    -accountId: AccountId
	    -balance: Money
	    -customerId: CustomerId
	    -status: AccountStatus
	    +credit(Money)
	    +debit(Money)
	    +getBalance() Money
    }

    class FraudCase {
	    -caseId: FraudCaseId
	    -paymentOrderId: PaymentOrderId
	    -riskScore: RiskScore
	    -status: CaseStatus
	    -detectionRules: List~RuleViolation~
	    +approve()
	    +reject()
	    +escalate()
    }

    class RiskScore {
	    -score: Integer
	    -confidence: Double
	    -factors: List~RiskFactor~
	    -mlModelVersion: String
    }

    class RiskFactor {
	    -factorType: FactorType
	    -value: String
	    -deviation: Double
    }

    class Customer {
	    -customerId: CustomerId
	    -personalInfo: PersonalInfo
	    -kycStatus: KYCStatus
	    -status: CustomerStatus
	    +activate()
	    +updateKYC(KYCStatus)
	    +suspend()
    }

    class PersonalInfo {
	    -fullName: FullName
	    -dateOfBirth: LocalDate
	    -email: Email
	    -phone: PhoneNumber
	    -taxId: TaxId
    }

    class KYCStatus {
	    -level: KYCLevel
	    -verifiedAt: Instant
	    -provider: KYCProvider
	    -biometricCaptured: boolean
	    +isExpired() boolean
    }

    class FXRate {
	    -rateId: FXRateId
	    -currencyPair: CurrencyPair
	    -spotRate: BigDecimal
	    -spread: BigDecimal
	    -clientRate: BigDecimal
	    +isValid() boolean
    }

    class FXLock {
	    -lockId: FXLockId
	    -paymentOrderId: PaymentOrderId
	    -currencyPair: CurrencyPair
	    -lockedRate: BigDecimal
	    -lockedAt: Instant
	    -expiresAt: Instant
	    +isValid() boolean
	    +consume()
    }

    class CurrencyPair {
	    -baseCurrency: Currency
	    -quoteCurrency: Currency
    }

	<<AggregateRoot>> PaymentOrder
	<<Entity>> PaymentItem
	<<ValueObject>> Money
	<<ValueObject>> BeneficiaryInfo
	<<ValueObject>> AccountIdentifier
	<<AggregateRoot>> LedgerEntry
	<<Entity>> Account
	<<AggregateRoot>> FraudCase
	<<ValueObject>> RiskScore
	<<ValueObject>> RiskFactor
	<<AggregateRoot>> Customer
	<<ValueObject>> PersonalInfo
	<<ValueObject>> KYCStatus
	<<AggregateRoot>> FXRate
	<<AggregateRoot>> FXLock
	<<ValueObject>> CurrencyPair

    PaymentOrder "1" *-- "many" PaymentItem : contains
    PaymentOrder --> Money : uses
    PaymentOrder --> BeneficiaryInfo : has
    BeneficiaryInfo --> AccountIdentifier : contains
    LedgerEntry --> Money : uses
    Account --> Money : has balance
    FraudCase --> RiskScore : has
    RiskScore --> RiskFactor : contains
    Customer --> PersonalInfo : has
    Customer --> KYCStatus : has
    FXLock --> CurrencyPair : has
    FXRate --> CurrencyPair : quotes
    PaymentOrder ..> Customer : references by CustomerId
    FraudCase ..> PaymentOrder : references by PaymentOrderId
    LedgerEntry ..> PaymentOrder : references by TransactionId
    Account ..> Customer : references by CustomerId
    FXLock ..> PaymentOrder : locks rate for

	style PaymentOrder fill:#ffcccc,stroke:#cc0000,stroke-width:2px,color:#000000

	style LedgerEntry fill:#ffcccc,stroke:#cc0000,stroke-width:2px,color:#000000

	style FraudCase fill:#ffcccc,stroke:#cc0000,stroke-width:2px,color:#000000

	style Customer fill:#fff4cc,stroke:#ccaa00,stroke-width:2px,color:#000000

	style FXRate fill:#ffe6cc,stroke:#cc6600,stroke-width:2px,color:#000000
	style FXLock fill:#ffe6cc,stroke:#cc6600,stroke-width:2px,color:#000000
```

### Vista de Eventos de Dominio

```mermaid
graph LR
    subgraph Payment["Payment Execution Context"]
        PE1[PaymentCreated]
        PE2[PaymentValidated]
        PE3[PaymentExecuted]
        PE4[PaymentSettled]
        PE5[PaymentFailed]
    end
    
    subgraph Ledger["General Ledger Context"]
        LE1[LedgerEntryCreated]
        LE2[BalanceUpdated]
    end
    
    subgraph Fraud["Fraud Detection Context"]
        FR1[FraudDetected]
        FR2[FraudCaseReviewed]
    end
    
    subgraph Customer["Customer Management Context"]
        CU1[CustomerRegistered]
        CU2[KYCVerified]
        CU3[CustomerActivated]
    end
    
    subgraph FX["Treasury & FX Context"]
        FX1[FXRateQuoted]
        FX2[FXRateLocked]
        FX3[FXLockConsumed]
    end
    
    PE1 --> FR1
    PE2 --> PE3
    PE3 --> LE1
    PE3 --> FX3
    LE1 --> LE2
    FR2 --> PE2
    CU2 --> CU3
    FX2 --> PE2
    
    style Payment fill:#ffcccc,stroke:#cc0000,stroke-width:2px,color:#000000
    style Ledger fill:#ffcccc,stroke:#cc0000,stroke-width:2px,color:#000000
    style Fraud fill:#ffcccc,stroke:#cc0000,stroke-width:2px,color:#000000
    style Customer fill:#fff4cc,stroke:#ccaa00,stroke-width:2px,color:#000000
    style FX fill:#ffe6cc,stroke:#cc6600,stroke-width:2px,color:#000000
```

---

## ðŸ“¦ Bounded Context: Payment Execution (CORE)

> **Responsabilidad**: OrquestaciÃ³n del pago con validaciÃ³n de saldo, reserva de fondos y enrutamiento a 50 paÃ­ses  
> **Compliance**: PCI-DSS (tokenizaciÃ³n, HSM, AES-256, audit logs)

### Agregado: PaymentOrder

**Aggregate Root**: PaymentOrder  
**PropÃ³sito**: Representa una orden de pago con su ciclo de vida completo desde creaciÃ³n hasta liquidaciÃ³n

```
PaymentOrder (Entity - Aggregate Root)
â”œâ”€â”€ orderId: PaymentOrderId (Value Object)
â”œâ”€â”€ originator: CustomerId (Value Object)
â”œâ”€â”€ beneficiary: BeneficiaryInfo (Value Object)
â”œâ”€â”€ amount: Money (Value Object)
â”œâ”€â”€ executionDate: Date
â”œâ”€â”€ status: PaymentStatus (Enum: DRAFT â†’ VALIDATED â†’ FX_LOCKED â†’ SENT_TO_GATEWAY â†’ CLEARING â†’ SETTLED / FAILED)
â”œâ”€â”€ paymentItems: List<PaymentItem> (Entity)
â”œâ”€â”€ routingInfo: RoutingDecision (Value Object)
â”œâ”€â”€ fxLockId: FXLockId (Value Object - opcional para pagos transfronterizos)
â””â”€â”€ auditTrail: List<StatusChange> (Value Object)

PaymentItem (Entity - parte del agregado)
â”œâ”€â”€ itemId: String
â”œâ”€â”€ amount: Money
â”œâ”€â”€ description: String
â””â”€â”€ metadata: Map<String, String>

Money (Value Object)
â”œâ”€â”€ amount: BigDecimal
â”œâ”€â”€ currency: Currency (Enum)
â””â”€â”€ equals(), hashCode()

BeneficiaryInfo (Value Object)
â”œâ”€â”€ beneficiaryId: String
â”œâ”€â”€ accountIdentifier: AccountIdentifier (Value Object - soporta IBAN/SWIFT/ACH segÃºn paÃ­s)
â”œâ”€â”€ bankCode: BIC (Value Object)
â”œâ”€â”€ name: String
â”œâ”€â”€ country: CountryCode (uno de 50 paÃ­ses soportados)
â””â”€â”€ address: Address (Value Object)

AccountIdentifier (Value Object)
â”œâ”€â”€ type: IdentifierType (IBAN, SWIFT, ACH, PIX, SPEI)
â”œâ”€â”€ value: String
â””â”€â”€ validate(): Boolean

Address (Value Object)
â”œâ”€â”€ street: String
â”œâ”€â”€ city: String
â”œâ”€â”€ country: CountryCode (Enum)
â””â”€â”€ postalCode: String
```

### Invariantes del Agregado

```java
class PaymentOrder {
    // Invariante 1: El monto total debe ser positivo
    private void validateAmount() {
        if (amount.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
    }
    
    // Invariante 2: Solo se puede ejecutar si estÃ¡ en estado VALIDATED
    public void execute() {
        if (status != PaymentStatus.VALIDATED) {
            throw new IllegalStateException("Can only execute validated payments");
        }
        this.status = PaymentStatus.EXECUTING;
        this.events.add(new PaymentExecuted(this.orderId));
    }
    
    // Invariante 3: No se puede modificar un pago ya ejecutado
    public void updateAmount(Money newAmount) {
        if (status == PaymentStatus.EXECUTED || status == PaymentStatus.SETTLED) {
            throw new IllegalStateException("Cannot modify executed payment");
        }
        this.amount = newAmount;
    }
}
```

### Domain Events

```
PaymentCreated
â”œâ”€â”€ orderId: PaymentOrderId
â”œâ”€â”€ amount: Money
â”œâ”€â”€ timestamp: Instant
â””â”€â”€ originatorId: CustomerId

PaymentValidated
â”œâ”€â”€ orderId: PaymentOrderId
â”œâ”€â”€ validationResult: ValidationResult
â””â”€â”€ timestamp: Instant

PaymentExecuted
â”œâ”€â”€ orderId: PaymentOrderId
â”œâ”€â”€ executionTimestamp: Instant
â””â”€â”€ routingNetwork: String

PaymentSettled
â”œâ”€â”€ orderId: PaymentOrderId
â”œâ”€â”€ settlementTimestamp: Instant
â””â”€â”€ settlementReference: String

PaymentFailed
â”œâ”€â”€ orderId: PaymentOrderId
â”œâ”€â”€ failureReason: String
â”œâ”€â”€ isRetryable: Boolean
â””â”€â”€ timestamp: Instant
```

### Repositories

```java
interface PaymentOrderRepository {
    PaymentOrder findById(PaymentOrderId id);
    List<PaymentOrder> findByOriginator(CustomerId customerId);
    List<PaymentOrder> findByStatus(PaymentStatus status);
    void save(PaymentOrder order);
}
```

### Domain Services

```java
class PaymentRoutingService {
    RoutingDecision determineRoute(PaymentOrder order) {
        // LÃ³gica compleja que no pertenece a PaymentOrder
        // - EvalÃºa paÃ­s destino
        // - Selecciona red Ã³ptima (SWIFT, SEPA, PIX)
        // - Considera costo + latencia
    }
}

class PaymentValidationService {
    ValidationResult validate(PaymentOrder order) {
        // Orquesta mÃºltiples validadores
        // - Sintaxis
        // - Saldo
        // - LÃ­mites
    }
}
```

---

## ðŸ“¦ Bounded Context: General Ledger (CORE)

> **Responsabilidad**: Contabilidad de doble entrada inmutable en tiempo real (Position Keeping)  
> **Compliance**: PCI-DSS (AES-256, TLS 1.3, Event Sourcing como log inmutable, MFA para ops admin)  
> **Arquitectura**: Event Sourcing como fuente de verdad - elimina 40% lÃ³gica PL/SQL actual

### Agregado: LedgerEntry

**Aggregate Root**: LedgerEntry (Inmutable - Event Sourcing)  
**PropÃ³sito**: Registro inmutable de doble entrada contable - una vez creado, nunca se modifica

```
LedgerEntry (Entity - Aggregate Root - Immutable)
â”œâ”€â”€ entryId: LedgerEntryId (Value Object)
â”œâ”€â”€ transactionId: TransactionId (Value Object)
â”œâ”€â”€ timestamp: Instant
â”œâ”€â”€ debitAccount: AccountId (Value Object)
â”œâ”€â”€ creditAccount: AccountId (Value Object)
â”œâ”€â”€ amount: Money (Value Object)
â”œâ”€â”€ entryType: EntryType (Enum: PAYMENT, REVERSAL, FEE)
â”œâ”€â”€ metadata: TransactionMetadata (Value Object)
â””â”€â”€ correlationId: String

AccountId (Value Object)
â”œâ”€â”€ accountNumber: String
â”œâ”€â”€ accountType: AccountType (Enum)
â””â”€â”€ equals(), hashCode()

TransactionMetadata (Value Object)
â”œâ”€â”€ paymentOrderId: String
â”œâ”€â”€ description: String
â”œâ”€â”€ tags: Set<String>
â””â”€â”€ customFields: Map<String, String>
```

### Invariantes del Ledger

```java
class LedgerEntry {
    // Invariante fundamental: Doble entrada balanceada
    private void validateDoubleEntry() {
        if (debitAccount.equals(creditAccount)) {
            throw new InvalidLedgerEntryException(
                "Debit and credit accounts must be different"
            );
        }
        // El monto es el mismo para dÃ©bito y crÃ©dito
        // Balance = 0 siempre
    }
    
    // Inmutabilidad: No hay setters, solo construcciÃ³n
    private LedgerEntry(Builder builder) {
        this.entryId = builder.entryId;
        this.debitAccount = builder.debitAccount;
        this.creditAccount = builder.creditAccount;
        this.amount = builder.amount;
        // Una vez creado, NUNCA cambia
    }
}
```

### Agregado: Account (Read Model - CQRS)

```
Account (Entity - Read Model)
â”œâ”€â”€ accountId: AccountId
â”œâ”€â”€ customerId: CustomerId
â”œâ”€â”€ balance: Money
â”œâ”€â”€ currency: Currency
â”œâ”€â”€ accountType: AccountType (CUSTOMER, CLEARING, NOSTRO)
â”œâ”€â”€ status: AccountStatus (ACTIVE, FROZEN, CLOSED)
â””â”€â”€ lastUpdated: Instant

// Este es un Read Model proyectado desde LedgerEntry events
// Se actualiza de forma eventual
```

### Domain Events

```
LedgerEntryCreated (Event Sourced)
â”œâ”€â”€ entryId: LedgerEntryId
â”œâ”€â”€ debitAccount: AccountId
â”œâ”€â”€ creditAccount: AccountId
â”œâ”€â”€ amount: Money
â””â”€â”€ timestamp: Instant

BalanceUpdated (Projected Event)
â”œâ”€â”€ accountId: AccountId
â”œâ”€â”€ newBalance: Money
â”œâ”€â”€ previousBalance: Money
â””â”€â”€ timestamp: Instant
```

### Repositories

```java
// Event Store para escritura
interface LedgerEventStore {
    void append(LedgerEntryCreated event);
    List<LedgerEntryCreated> loadEvents(TransactionId transactionId);
}

// Read Model para consultas
interface AccountRepository {
    Account findById(AccountId id);
    Money getBalance(AccountId id);
}
```

---

## ðŸ“¦ Bounded Context: Fraud Detection (CORE)

> **Responsabilidad**: DetecciÃ³n de fraude en tiempo real con ML (SLA < 100ms)  
> **Compliance**: GDPR (derecho al olvido mediante anonimizaciÃ³n, consentimiento explÃ­cito para ML scoring, retenciÃ³n 7 aÃ±os + anonimizaciÃ³n, audit logs)  
> **MigraciÃ³n**: Reemplaza 40% lÃ³gica PL/SQL actual por servicio independiente con ML en tiempo real

### Agregado: FraudCase

**Aggregate Root**: FraudCase  
**PropÃ³sito**: Representa un caso de anÃ¡lisis de fraude con su scoring y decisiÃ³n (automÃ¡tica o manual)

```
FraudCase (Entity - Aggregate Root)
â”œâ”€â”€ caseId: FraudCaseId (Value Object)
â”œâ”€â”€ paymentOrderId: PaymentOrderId
â”œâ”€â”€ riskScore: RiskScore (Value Object: 0-100)
â”œâ”€â”€ status: CaseStatus (PENDING, APPROVED, REJECTED, ESCALATED)
â”œâ”€â”€ detectionRules: List<RuleViolation> (Value Object)
â”œâ”€â”€ reviewNotes: List<ReviewNote> (Entity)
â”œâ”€â”€ createdAt: Instant
â”œâ”€â”€ reviewedAt: Instant
â””â”€â”€ reviewedBy: AnalystId

RiskScore (Value Object)
â”œâ”€â”€ score: Integer (0-100)
â”œâ”€â”€ confidence: Double (0.0-1.0)
â”œâ”€â”€ factors: List<RiskFactor>
â”œâ”€â”€ threshold: ScoreThreshold
â””â”€â”€ mlModelVersion: String

RuleViolation (Value Object)
â”œâ”€â”€ ruleId: String
â”œâ”€â”€ ruleName: String
â”œâ”€â”€ severity: Severity (LOW, MEDIUM, HIGH, CRITICAL)
â”œâ”€â”€ contribution: Integer (puntos al score)
â””â”€â”€ evidence: Map<String, Object>

RiskFactor (Value Object)
â”œâ”€â”€ factorType: FactorType (VELOCITY, GEO_MISMATCH, DEVICE_FINGERPRINT, AMOUNT_ANOMALY, ACCOUNT_TAKEOVER)
â”œâ”€â”€ value: String
â”œâ”€â”€ normalValue: String
â””â”€â”€ deviation: Double
```

### Domain Services

```java
class FraudScoringService {
    RiskScore calculateScore(PaymentOrder order, CustomerBehavior behavior) {
        // ML Model Serving
        // Feature Engineering
        // Real-time scoring
    }
}

class RuleEngine {
    List<RuleViolation> evaluateRules(PaymentOrder order) {
        // EvalÃºa reglas estÃ¡ticas
        // - Velocity (5 pagos en 1 hora)
        // - Monto inusual (3x promedio)
        // - PaÃ­s de riesgo
    }
}
```

### Domain Events

```
FraudDetected
â”œâ”€â”€ caseId: FraudCaseId
â”œâ”€â”€ paymentOrderId: PaymentOrderId
â”œâ”€â”€ riskScore: RiskScore
â”œâ”€â”€ autoDecision: Decision (BLOCK, ALLOW, REVIEW)
â””â”€â”€ timestamp: Instant

FraudCaseReviewed
â”œâ”€â”€ caseId: FraudCaseId
â”œâ”€â”€ decision: Decision
â”œâ”€â”€ reviewedBy: AnalystId
â””â”€â”€ timestamp: Instant
```

---

## ðŸ“¦ Bounded Context: Customer Management

> **Subdominios**: Customer Onboarding, Beneficiary Management, Wallet Overview  
> **Compliance**: GDPR (consentimiento explÃ­cito por etapa, derecho al olvido, minimizaciÃ³n datos, DPA con Jumio/Onfido)  
> **Integraciones**: Jumio, Onfido (webhooks asincrÃ³nicos para KYC)

### Agregado: Customer

**Aggregate Root**: Customer  
**PropÃ³sito**: Representa un cliente (persona o empresa) con su informaciÃ³n personal y estado de verificaciÃ³n KYC

```
Customer (Entity - Aggregate Root)
â”œâ”€â”€ customerId: CustomerId (Value Object)
â”œâ”€â”€ personalInfo: PersonalInfo (Value Object)
â”œâ”€â”€ kycStatus: KYCStatus (Value Object)
â”œâ”€â”€ accounts: List<AccountId> (referencia, no ownership)
â”œâ”€â”€ verificationDocuments: List<Document> (Entity)
â”œâ”€â”€ status: CustomerStatus (ACTIVE, SUSPENDED, CLOSED)
â”œâ”€â”€ createdAt: Instant
â””â”€â”€ lastModified: Instant

PersonalInfo (Value Object)
â”œâ”€â”€ fullName: FullName (Value Object)
â”œâ”€â”€ dateOfBirth: LocalDate
â”œâ”€â”€ nationality: CountryCode
â”œâ”€â”€ taxId: TaxId (Value Object)
â”œâ”€â”€ email: Email (Value Object)
â””â”€â”€ phone: PhoneNumber (Value Object)

FullName (Value Object)
â”œâ”€â”€ firstName: String
â”œâ”€â”€ middleName: String
â”œâ”€â”€ lastName: String
â””â”€â”€ displayName(): String

KYCStatus (Value Object)
â”œâ”€â”€ level: KYCLevel (NONE, BASIC, ENHANCED, FULL)
â”œâ”€â”€ verifiedAt: Instant
â”œâ”€â”€ expiresAt: Instant
â”œâ”€â”€ provider: KYCProvider (JUMIO, ONFIDO - segÃºn kata)
â”œâ”€â”€ verificationId: String
â””â”€â”€ biometricCaptured: Boolean

Document (Entity)
â”œâ”€â”€ documentId: String
â”œâ”€â”€ documentType: DocumentType (ID, PASSPORT, PROOF_ADDRESS)
â”œâ”€â”€ fileUrl: String
â”œâ”€â”€ uploadedAt: Instant
â””â”€â”€ verificationStatus: VerificationStatus
```

### Invariantes

```java
class Customer {
    // Invariante: No se puede activar sin KYC BASIC
    public void activate() {
        if (kycStatus.getLevel() == KYCLevel.NONE) {
            throw new IllegalStateException(
                "Cannot activate customer without KYC verification"
            );
        }
        this.status = CustomerStatus.ACTIVE;
    }
    
    // Invariante: Email debe ser Ãºnico (verificado por repositorio)
    public void updateEmail(Email newEmail) {
        // Repository verifica unicidad
        this.personalInfo = personalInfo.withEmail(newEmail);
        this.events.add(new CustomerEmailUpdated(customerId, newEmail));
    }
}
```

---

## ðŸ“¦ Bounded Context: Treasury & FX

> **Subdominios**: FX Trading, Liquidity Management  
> **Responsabilidad**: CotizaciÃ³n y bloqueo de tasas de cambio para pagos transfronterizos, monitoreo de liquidez en bancos corresponsales  
> **CaracterÃ­stica clave**: Tasa bloqueada por 5 minutos segÃºn proceso de negocio de la kata

### Agregado: FXRate

**Aggregate Root**: FXRate  
**PropÃ³sito**: Representa una cotizaciÃ³n de divisa con spread comercial aplicado

```
FXRate (Entity - Aggregate Root)
â”œâ”€â”€ rateId: FXRateId
â”œâ”€â”€ currencyPair: CurrencyPair (Value Object)
â”œâ”€â”€ spotRate: BigDecimal
â”œâ”€â”€ spread: BigDecimal
â”œâ”€â”€ clientRate: BigDecimal (spotRate + spread)
â”œâ”€â”€ validFrom: Instant
â”œâ”€â”€ validUntil: Instant
â”œâ”€â”€ source: RateSource (REUTERS, BLOOMBERG)
â””â”€â”€ rateType: RateType (SPOT, FORWARD)

CurrencyPair (Value Object)
â”œâ”€â”€ baseCurrency: Currency
â”œâ”€â”€ quoteCurrency: Currency
â””â”€â”€ toString(): String (ej. "USD/EUR")
```

### Agregado: FXLock

```
FXLock (Entity - Aggregate Root)
â”œâ”€â”€ lockId: FXLockId
â”œâ”€â”€ paymentOrderId: PaymentOrderId
â”œâ”€â”€ currencyPair: CurrencyPair
â”œâ”€â”€ lockedRate: BigDecimal
â”œâ”€â”€ amount: Money
â”œâ”€â”€ lockedAt: Instant
â”œâ”€â”€ expiresAt: Instant (lockedAt + 5 minutos segÃºn kata)
â”œâ”€â”€ status: LockStatus (ACTIVE, EXPIRED, CONSUMED)
â””â”€â”€ consumedAt: Instant

// Invariante crÃ­tico de negocio: Lock vÃ¡lido SOLO por 5 minutos
// SegÃºn proceso "Transferencia Internacional (P2P)" de la kata
public boolean isValid() {
    Duration lockDuration = Duration.between(lockedAt, Instant.now());
    return status == LockStatus.ACTIVE 
        && lockDuration.toMinutes() < 5
        && Instant.now().isBefore(expiresAt);
}
```

### Domain Services

```java
class FXPricingService {
    FXRate getRate(CurrencyPair pair) {
        // Consulta provider externo
        // Aplica spread comercial
        // Cachea con TTL de 10 segundos
    }
    
    FXLock lockRate(CurrencyPair pair, Money amount, Duration lockDuration) {
        FXRate currentRate = getRate(pair);
        return new FXLock(
            generateId(),
            currentRate.getClientRate(),
            amount,
            lockDuration
        );
    }
}
```

---

##  Relaciones entre Agregados (Across Contexts)

### Regla: Solo Referencias por ID

```java
// âŒ MAL: Agregar referencia directa al objeto
class PaymentOrder {
    private Customer customer; // NO!
}

// âœ… BIEN: Solo mantener el ID
class PaymentOrder {
    private CustomerId originatorId; // Solo el ID
    
    // Si necesitas datos del Customer, usa un Repository
    public CustomerInfo getOriginatorInfo(CustomerRepository repo) {
        return repo.findById(this.originatorId).getPersonalInfo();
    }
}
```

### ComunicaciÃ³n entre Agregados: Domain Events

```java
// Payment Processing emite evento
class PaymentOrder {
    public void execute() {
        this.status = PaymentStatus.EXECUTING;
        this.events.add(new PaymentExecuted(this.orderId, this.amount));
    }
}

// General Ledger escucha evento
class LedgerEventHandler {
    @EventHandler
    public void on(PaymentExecuted event) {
        LedgerEntry entry = new LedgerEntry.Builder()
            .debit(event.getOriginatorAccount())
            .credit(CLEARING_ACCOUNT)
            .amount(event.getAmount())
            .build();
        
        ledgerEventStore.append(entry);
    }
}
```

---

**PrÃ³ximo Paso**: â†’ `03-DiseÃ±o-Tecnico/3.1-C4-Model/C1-Contexto.md`

---

**Ãšltima actualizaciÃ³n**: 22 de diciembre de 2025
