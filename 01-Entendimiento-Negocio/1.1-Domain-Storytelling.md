# 1.1 Domain Storytelling - Procesos de Negocio CrÃ­ticos

> **Objetivo**: Visualizar los flujos actuales del negocio identificando actores, interacciones y puntos de dolor.  
> **TÃ©cnica**: Domain Storytelling (WhyDD)  
> **Herramienta sugerida**: Extension Mermaid Preview para VSCode o directo en https://mermaid.live/

---

## ğŸ“– Proceso 1: Transferencia Internacional P2P

### Narrativa del Proceso

**Historia del Usuario:**  
_"Un cliente quiere enviar dinero internacional a travÃ©s de FinScale. El sistema debe procesar la transferencia manteniendo consistencia estricta en saldos y cumpliendo el SLA de fraude (< 100ms)."_

### Diagrama Domain Storytelling

> **TÃ­tulo**: Transferencia Internacional P2P USDâ†’EUR - Camino Feliz  
> **Contexto**: Cliente envÃ­a dinero internacional, sistema mantiene consistencia estricta y cumple SLA fraude < 100ms

```mermaid
flowchart LR
    Cliente(["ğŸ‘¤ Cliente"])
    App(["ğŸ“± App MÃ³vil"])
    Monolito(["ğŸ¦ Monolito J2EE"])
    MotorFX(["ğŸ’± Motor FX"])
    MotorFraude(["ğŸš¨ Motor Fraude"])
    Ledger(["ğŸ“’ Ledger"])
    Tesoreria(["ğŸ›ï¸ TesorerÃ­a"])
    OracleDB(["ğŸ—„ï¸ Oracle DB"])
    BancoPartner(["ğŸ¦ Banco Partner"])
    
    OpcionEnvio["ğŸ“‹ OpciÃ³n Enviar Dinero"]
    Transferencia1["ğŸ’µ Transferencia USD"]
    IDTx["ğŸ·ï¸ ID TransacciÃ³n"]
    Saldo1["ğŸ’° Saldo Cliente"]
    ParCotizacion["ğŸ’± Par USD/EUR"]
    TasaCambio["ğŸ“Š Tasa Cambio"]
    TasaBloqueada["ğŸ”’ Tasa 5min"]
    Cotizacion["ğŸ’¶ CotizaciÃ³n EUR"]
    Biometria["ğŸ‘† Touch ID"]
    OrdenPago["ğŸ“ Orden Pago"]
    AnalisisFraude["ğŸ” AnÃ¡lisis Riesgo"]
    ReglasSQL["ğŸ“œ Reglas PL/SQL"]
    ScoreAprobado["âœ… Score Aprobado"]
    AsientoDebito["ğŸ“Š Asiento DÃ©bito"]
    CuentaCliente["ğŸ’³ Cuenta Cliente"]
    CuentaPuente["ğŸ¦ Cuenta Puente"]
    InstruccionPago["ğŸ“¤ InstrucciÃ³n Pago"]
    FirmaHSM["ğŸ” Firma HSM"]
    MensajeSWIFT["ğŸ“¨ SWIFT pacs.008"]
    NotifEnCamino["ğŸ”” NotificaciÃ³n"]
    MensajeEnCamino["ğŸš€ En Camino"]
    ConfirmSWIFT["ğŸ“¬ SWIFT pacs.002"]
    EstadoCompletado["âœ”ï¸ Estado Completado"]
    AsientoCierre["ğŸ“Š Asiento Cierre"]
    CuentaLiquidada["ğŸ’¼ Cuenta Liquidada"]
    NotifFinal["ğŸ”” NotificaciÃ³n Final"]
    MensajeFinal["âœ… Completada"]
    
    Cliente -->|1 - Selecciona| OpcionEnvio
    OpcionEnvio --> App
    App -->|2 - Inicia| Transferencia1
    Transferencia1 --> Monolito
    Monolito -->|3 - Genera| IDTx
    IDTx --> OracleDB
    Monolito -->|4 - Valida| Saldo1
    Saldo1 --> OracleDB
    Monolito -->|5 - Cotiza| ParCotizacion
    ParCotizacion --> MotorFX
    MotorFX -->|6 - Consulta| TasaCambio
    TasaCambio --> OracleDB
    MotorFX -->|7 - Bloquea| TasaBloqueada
    MotorFX -->|8 - Muestra| Cotizacion
    Cotizacion --> App
    Cliente -->|9 - Confirma con| Biometria
    Biometria --> App
    App -->|10 - EnvÃ­a| OrdenPago
    OrdenPago --> Monolito
    Monolito -->|11 - Solicita| AnalisisFraude
    AnalisisFraude --> MotorFraude
    MotorFraude -->|12 - Ejecuta| ReglasSQL
    ReglasSQL --> OracleDB
    MotorFraude -->|13 - Retorna| ScoreAprobado
    ScoreAprobado --> Monolito
    Monolito -->|14 - Registra| AsientoDebito
    AsientoDebito --> Ledger
    Ledger -->|15 - Debita| CuentaCliente
    CuentaCliente --> OracleDB
    Ledger -->|16 - Acredita| CuentaPuente
    CuentaPuente --> OracleDB
    Monolito -->|17 - EnvÃ­a| InstruccionPago
    InstruccionPago --> Tesoreria
    Tesoreria -->|18 - Genera| FirmaHSM
    Tesoreria -->|19 - EnvÃ­a| MensajeSWIFT
    MensajeSWIFT --> BancoPartner
    Monolito -->|20 - EnvÃ­a| NotifEnCamino
    NotifEnCamino --> App
    App -->|21 - Muestra| MensajeEnCamino
    MensajeEnCamino --> Cliente
    BancoPartner -->|22 - EnvÃ­a| ConfirmSWIFT
    ConfirmSWIFT --> Tesoreria
    Tesoreria -->|23 - Actualiza| EstadoCompletado
    EstadoCompletado --> Monolito
    Monolito -->|24 - Solicita| AsientoCierre
    AsientoCierre --> Ledger
    Ledger -->|25 - Debita| CuentaPuente
    Ledger -->|26 - Acredita| CuentaLiquidada
    CuentaLiquidada --> OracleDB
    Monolito -->|27 - EnvÃ­a| NotifFinal
    NotifFinal --> App
    App -->|28 - Muestra| MensajeFinal
    MensajeFinal --> Cliente
    
    style Cliente fill:#e1f5ff
    style App fill:#fff3e0
    style Monolito fill:#ffebee
    style OracleDB fill:#f3e5f5
```

**Actores Identificados:**
- ğŸ‘¤ Cliente | ğŸ“± App MÃ³vil | ğŸ¦ Monolito Core Bancario (Java 8 J2EE)
- ğŸ’± Motor FX | ğŸš¨ Motor de Fraude (Stored Procedures PL/SQL) | ğŸ“’ Ledger (Contabilidad)
- ğŸ›ï¸ TesorerÃ­a (SWIFT) | ğŸ¦ Banco Partner | ğŸ—„ï¸ Oracle DB (Centralizada)

### Pasos del Proceso

**Los 8 pasos del "Camino Feliz" con contexto tÃ©cnico del sistema legacy:**

```
1. Cliente inicia transferencia desde la App (USD a EUR)
   - App MÃ³vil consulta disponibilidad al Monolito J2EE
   - DOLOR: Sticky Sessions (HttpSession en RAM) impide escalado horizontal
   - Monolito genera ID Ãºnico usando secuencia Oracle centralizada
   - DOLOR: Secuencias globales son cuello de botella en sistema distribuido
   - Monolito valida saldo en Oracle DB

2. Sistema cotiza la tasa de cambio (FX) y la bloquea por 5 minutos
   - Motor FX (dentro del Monolito) consulta Oracle
   - Genera cotizaciÃ³n y la retorna a la App

3. Cliente confirma con biometrÃ­a
   - App envÃ­a orden de pago al Monolito
   - DOLOR: God Class TransactionManager.java (15K lÃ­neas) con acoplamiento cÃ­clico
   - Imposible desplegar mÃ³dulos independientes

4. Motor de Fraude analiza en < 100ms. Si es verde â†’ continÃºa
   - Monolito invoca stored procedure PL/SQL
   - Analiza: Velocidad transaccional, GeolocalizaciÃ³n, Scoring
   - DOLOR: 40% de lÃ³gica en PL/SQL, imposible migrar mÃ³dulo

5. Ledger debita saldo del cliente (USD) y acredita cuenta puente interna (USD)
   - Ejecuta doble entrada contable
   - DOLOR: Locks de escritura en BD bloquean otras transacciones

6. TesorerÃ­a instruye al Banco Partner en Europa para pagar al destinatario final (EUR)
   - DOLOR: API sÃ­ncrona bloqueante (frontend espera respuesta inmediata)
   - Firma mensaje con HSM fÃ­sico on-premise
   - DOLOR: HSM fÃ­sico dificulta migraciÃ³n a Cloud
   - Genera mensaje SWIFT (ISO 20022 pacs.008)
   - DOLOR: ConexiÃ³n TCP/IP stateful dificulta escalado

7. Sistema notifica al cliente "EnvÃ­o en proceso"

8. Al recibir confirmaciÃ³n del Banco Partner, Ledger mueve fondos de cuenta puente a cuenta liquidada
   - Banco responde con SWIFT pacs.002
   - TesorerÃ­a actualiza estado
   - Ledger cierra asiento contable
   - Sistema notifica "Completado"
```

### Puntos de Dolor Identificados

| # | Punto de Dolor | Impacto en Negocio | Causa TÃ©cnica |
|---|---------------|---------------------|---------------|
| 1 | **Sticky Sessions** | Imposible escalado horizontal dinÃ¡mico. Si un servidor muere, se desconectan todos sus usuarios. | HttpSession en memoria RAM del servidor (Paso 1) |
| 2 | **Secuencias Globales IDs** | Cuello de botella para generar IDs Ãºnicos. Punto Ãºnico de fallo. | Secuencias Oracle centralizadas para IDs de transacciÃ³n (Paso 1) |
| 3 | **God Classes** | Imposible compilar/desplegar mÃ³dulos aislados. Despliegues requieren 6h ventana. | TransactionManager.java (15K lÃ­neas) con acoplamiento cÃ­clico (Paso 3) |
| 4 | **LÃ³gica atrapada en PL/SQL (40%)** | Time-to-market de 4 meses. Cambios requieren DBA, no DevOps. | Reglas de fraude en stored procedures imposibilita extraer mÃ³dulo independiente (Paso 4) |
| 5 | **Bloqueos en Base de Datos** | Imposibilidad de escalar mÃ³dulos individualmente. El mÃ³dulo de fraude tumba el de pagos. | Locks de escritura en BD durante doble entrada contable bloquean otras transacciones (Paso 5) |
| 6 | **APIs SÃ­ncronas Bloqueantes** | Frontend espera respuesta inmediata. Incompatible con arquitectura event-driven. | Clientes legacy esperan HTTP 200 OK sÃ­ncrono tras enviar transacciÃ³n (Paso 6) |
| 7 | **HSM FÃ­sico On-Premise** | Dificulta migraciÃ³n a Cloud. Requiere acceso remoto con latencia mÃ­nima. | Llaves criptogrÃ¡ficas residen en HSM fÃ­sico en datacenter (Paso 6) |
| 8 | **ConexiÃ³n SWIFT Stateful** | Dificulta escalado horizontal. Cada nodo requiere conexiÃ³n TCP persistente. | Protocolo ISO 8583 sobre TCP crudo con sesiones persistentes (Paso 6) |

---

## ğŸ“– Proceso 2: ReconciliaciÃ³n Nocturna (Batch)

### Narrativa del Proceso

**Contexto:**  
_"Diariamente, FinScale debe conciliar las transacciones internas con los extractos bancarios de sus bancos corresponsales."_

### Diagrama Domain Storytelling

> **TÃ­tulo**: ReconciliaciÃ³n Nocturna Batch 00:00 UTC  
> **Contexto**: FinScale concilia transacciones internas con extractos de bancos corresponsales  
> **CrÃ­tico**: Sistema bloquea BD 6 horas en modo READ-ONLY  
> **Nota**: Este proceso es independiente de la ventana general de batch (02:00-04:00 AM para cierres contables)

```mermaid
flowchart LR
    Scheduler(["â° Scheduler Cron"])
    SistemaRecon(["ğŸ¦ Sistema ReconciliaciÃ³n"])
    OracleDB(["ğŸ—„ï¸ Oracle DB"])
    BancosCorresp(["ğŸ›ï¸ Bancos Corresponsales"])
    EquipoOps(["ğŸ‘¥ Equipo Operaciones"])
    
    JobRecon["âš™ï¸ Job ReconciliaciÃ³n"]
    ModoReadOnly["ğŸ”’ Modo READ-ONLY"]
    SolicitudExtractos["ğŸ“¥ Solicitud Extractos"]
    ArchivosMT940["ğŸ“„ MT940 SWIFT"]
    ArchivosCAMT["ğŸ“„ CAMT.053 SEPA"]
    ArchivosJSON["ğŸ“„ JSON REST"]
    DatosCrudos["ğŸ“¦ Datos Crudos"]
    TablasTemp["ğŸ—‚ï¸ Tablas CORE_SCHEMA"]
    ProcedureSQL["âš™ï¸ Procedure PL/SQL"]
    JoinMasivo["ğŸ”— JOIN Extractos vs Ledger"]
    Discrepancias["âŒ Discrepancias"]
    ReporteExcel["ğŸ“Š Reporte Excel"]
    EmailsAlertas["ğŸ“§ Emails Alertas"]
    UpdateMasivo["âœ”ï¸ UPDATE Masivo"]
    ModoReadWrite["ğŸ”“ Modo READ-WRITE"]
    
    Scheduler -->|1 - Dispara| JobRecon
    JobRecon --> SistemaRecon
    SistemaRecon -->|2 - Cambia a| ModoReadOnly
    ModoReadOnly --> OracleDB
    SistemaRecon -->|3 - Solicita| SolicitudExtractos
    SolicitudExtractos --> BancosCorresp
    BancosCorresp -->|4 - Retorna| ArchivosMT940
    ArchivosMT940 --> SistemaRecon
    BancosCorresp -->|5 - Retorna| ArchivosCAMT
    ArchivosCAMT --> SistemaRecon
    BancosCorresp -->|6 - Retorna| ArchivosJSON
    ArchivosJSON --> SistemaRecon
    SistemaRecon -->|7 - Parsea| DatosCrudos
    SistemaRecon -->|8 - Carga en| TablasTemp
    TablasTemp --> OracleDB
    SistemaRecon -->|9 - Ejecuta| ProcedureSQL
    ProcedureSQL --> OracleDB
    OracleDB -->|10 - Realiza| JoinMasivo
    OracleDB -->|11 - Identifica| Discrepancias
    Discrepancias --> SistemaRecon
    SistemaRecon -->|12 - Genera| ReporteExcel
    SistemaRecon -->|13 - EnvÃ­a| EmailsAlertas
    EmailsAlertas --> EquipoOps
    SistemaRecon -->|14 - Ejecuta| UpdateMasivo
    UpdateMasivo --> OracleDB
    SistemaRecon -->|15 - Libera a| ModoReadWrite
    ModoReadWrite --> OracleDB
    
    style SistemaRecon fill:#fff3e0
    style OracleDB fill:#ffebee
    style BancosCorresp fill:#e8f5e9
```

**Actores Identificados:**
- â° Scheduler (Cron) | ğŸ¦ Sistema ReconciliaciÃ³n | ğŸ—„ï¸ Oracle DB
- ğŸ›ï¸ Bancos Corresponsales | ğŸ‘¥ Equipo Operaciones

### Pasos del Proceso

**Los 3 pasos del "Dolor de Cabeza" con contexto tÃ©cnico del sistema legacy:**

```
1. A las 00:00 UTC, FinScale descarga los extractos de todos los bancos aliados
   - Scheduler (Cron) dispara job de reconciliaciÃ³n
   - Sistema cambia BD a modo READ-ONLY
   - DOLOR CRÃTICO: Sistema bloquea operaciÃ³n 24/7 durante 6 horas
   - Descarga vÃ­a SFTP (MT940, CAMT.053) y REST APIs
   - Parsea archivos y carga en tablas temporales (CORE_SCHEMA)
   - DOLOR: Shared Database - Sistemas satÃ©lites (Reportes, CRM, Fraude Legacy) leen/escriben directo
   - Cambios de esquema rompen integraciones desconocidas

2. El sistema cruza cada movimiento bancario contra el Ledger interno
   - Ejecuta stored procedure de reconciliaciÃ³n (PL/SQL)
   - JOIN masivo entre extractos bancarios y registros del Ledger
   - DOLOR CRÃTICO: Gran volumen causa timeout y alto consumo CPU
   - Identifica: coincidencias, faltantes en banco, faltantes en Ledger, diferencias de monto

3. Desviaciones: Si el banco dice que salieron $100 pero el Ledger dice $90,
   se genera una alerta de nivel crÃ­tico para el equipo de operaciones manuales
   - Genera reporte de excepciones (Excel)
   - EnvÃ­a mÃºltiples emails al equipo
   - DOLOR: Sin priorizaciÃ³n, intervenciÃ³n manual requerida, no escala
   - Marca transacciones reconciliadas (UPDATE masivo)
   - Libera BD a modo READ-WRITE
   
[FIN] Actualmente este proceso tarda 6 horas y bloquea la base de datos
```

### Puntos de Dolor Identificados

| # | Punto de Dolor | Impacto | Criticidad |
|---|---------------|---------|------------|
| 1 | **Ventana de ReconciliaciÃ³n Bancaria (6 horas)** | Sistema en READ-ONLY 00:00-06:00 UTC para reconciliar extractos bancarios vs Ledger. Bloquea operaciÃ³n 24/7. | ğŸ”´ CRÃTICO |
| 2 | **LÃ³gica en PL/SQL (40%)** | Imposible migrar mÃ³dulo de reconciliaciÃ³n sin reescribir stored procedures | ğŸ”´ CRÃTICO |
| 3 | **Shared Database (IntegraciÃ³n por BD)** | Sistemas satÃ©lites leen/escriben directo en CORE_SCHEMA. Cambios de esquema rompen integraciones desconocidas. | ğŸ”´ CRÃTICO |
| 4 | **IntervenciÃ³n manual requerida** | Desviaciones requieren equipo de operaciones manuales | ğŸŸ¡ ALTO |

---

## ğŸ“– Proceso 3: DetecciÃ³n de Fraude en Tiempo Real

### Narrativa del Proceso

**Contexto:**  
_"Cada transacciÃ³n debe pasar por el motor de fraude antes de ejecutarse. El sistema debe detectar patrones anÃ³malos en < 100ms."_

### Diagrama Domain Storytelling

> **TÃ­tulo**: DetecciÃ³n de Fraude Tiempo Real - Caso Bajo Riesgo  
> **Contexto**: TransacciÃ³n analizada en < 100ms y aprobada automÃ¡ticamente  
> **Nota**: Casos Riesgo Medio y Alto Riesgo son historias separadas

```mermaid
flowchart LR
    Cliente(["ğŸ‘¤ Cliente"])
    App(["ğŸ“± App"])
    Monolito(["ğŸ¦ Monolito"])
    MotorFraude(["ğŸš¨ Motor Fraude"])
    OracleDB(["ğŸ—„ï¸ Oracle DB"])
    
    Transaccion["ğŸ’³ TransacciÃ³n"]
    OrdenPago["ğŸ“ Orden Pago"]
    AnalisisRiesgo["ğŸ” AnÃ¡lisis Riesgo"]
    ReglaVelocidad["âš¡ Regla Velocidad"]
    ReglaGeo["ğŸŒ Regla GeolocalizaciÃ³n"]
    ReglaScoring["ğŸ“Š Regla Scoring"]
    ScoreBajoRiesgo["âœ… Score Bajo Riesgo"]
    ProcesamientoPago["ğŸ’° Procesamiento Pago"]
    
    Cliente -->|1 - Inicia| Transaccion
    Transaccion --> App
    App -->|2 - EnvÃ­a| OrdenPago
    OrdenPago --> Monolito
    Monolito -->|3 - Solicita| AnalisisRiesgo
    AnalisisRiesgo --> MotorFraude
    MotorFraude -->|4 - Ejecuta| ReglaVelocidad
    ReglaVelocidad --> OracleDB
    MotorFraude -->|5 - Ejecuta| ReglaGeo
    ReglaGeo --> OracleDB
    MotorFraude -->|6 - Ejecuta| ReglaScoring
    ReglaScoring --> OracleDB
    MotorFraude -->|7 - Retorna| ScoreBajoRiesgo
    ScoreBajoRiesgo --> Monolito
    Monolito -->|8 - ContinÃºa con| ProcesamientoPago
    
    style Cliente fill:#e1f5ff
    style Monolito fill:#ffebee
    style MotorFraude fill:#fff3e0
    style OracleDB fill:#f3e5f5
```

**Actores Identificados:**
- ğŸ‘¤ Cliente | ğŸ“± App | ğŸ¦ Monolito | ğŸš¨ Motor Fraude (PL/SQL) | ğŸ—„ï¸ Oracle DB | ğŸ‘¥ Equipo Fraude

**SLA CrÃ­tico:** < 100ms por transacciÃ³n

### Pasos del Proceso Actual

```
1. Cliente â†’ inicia transacciÃ³n â†’ App
2. App â†’ envÃ­a orden de pago â†’ Monolito
3. Monolito â†’ invoca stored procedure de anÃ¡lisis de fraude (PL/SQL)
4. Stored Procedure â†’ ejecuta reglas de fraude:
   - Velocidad transaccional
   - GeolocalizaciÃ³n (IP vs GPS del dispositivo)
   - Scoring de riesgo
   - Otras validaciones segÃºn contexto
5. Stored Procedure â†’ calcula score de riesgo
6. Stored Procedure â†’ retorna veredicto:
   - BAJO RIESGO: Auto-aprobar
   - RIESGO MEDIO: Requiere validaciÃ³n adicional (2FA)
   - ALTO RIESGO: Bloquear transacciÃ³n
7. Monolito â†’ actÃºa segÃºn veredicto
8. Si es ALTO RIESGO â†’ Sistema genera alerta al equipo de fraude
```

### Puntos de Dolor Identificados

| # | Punto de Dolor | Impacto en Negocio | Causa TÃ©cnica |
|---|---------------|---------------------|---------------|
| 1 | **LÃ³gica en PL/SQL (40%)** | Imposible migrar mÃ³dulo de fraude de forma independiente sin reescribir lÃ³gica | Stored Procedures de anÃ¡lisis de fraude en Oracle |
| 2 | **Acoplamiento con Monolito** | El mÃ³dulo de fraude tumba el de pagos cuando falla | Imposibilidad de escalar mÃ³dulos individualmente |
| 3 | **SLA de < 100ms requerido** | Debe cumplir anÃ¡lisis en menos de 100ms | Base de datos centralizada con stored procedures PL/SQL |

---

## ğŸ¯ AnÃ¡lisis de Actores y Sistemas

### Actores Humanos

| Actor | Rol | InteracciÃ³n Principal | Pain Points |
|-------|-----|----------------------|-------------|
| **Cliente (Persona)** | Ordenante/Beneficiario | App MÃ³vil, Web | Latencia, falta de visibilidad del estado en clearing |
| **Cliente Empresa** | Ordenante masivo (payroll) | API REST, SFTP Batch | LÃ­mites de throughput, ventanas de batch nocturno |
| **Operador de TesorerÃ­a** | Monitoreo de liquidez | Dashboard Interno | Alertas manuales, proceso de reconciliaciÃ³n bloqueante |
| **Analista de Fraude** | RevisiÃ³n de casos sospechosos | Panel de Fraude | Sobrecarga de alertas, intervenciÃ³n manual requerida |
| **Equipo de Desarrollo** | Mantenimiento del sistema | Monolito Java | Despliegues lentos (ventana 6h), debugging complejo |

### Sistemas Participantes

| Sistema | Responsabilidad | TecnologÃ­a Actual | Criticidad |
|---------|----------------|-------------------|------------|
| **App MÃ³vil/Web** | Interfaz de usuario | Cliente Legacy | ğŸŸ¢ |
| **Monolito Core** | OrquestaciÃ³n de negocio | Java 8 J2EE | ğŸ”´ |
| **Base de Datos Oracle** | Persistencia + LÃ³gica de negocio | Oracle con PL/SQL | ğŸ”´ |
| **Motor de Fraude** | DetecciÃ³n de anomalÃ­as | PL/SQL + Java | ğŸ”´ |
| **Ledger** | Contabilidad doble entrada | PL/SQL | ğŸ”´ |
| **TesorerÃ­a** | ComunicaciÃ³n con bancos | Java (ISO 8583 sobre TCP) | ğŸŸ¡ |
| **Sistema de Notificaciones** | Push, Email, SMS | Parte del Monolito | ğŸŸ¢ |

---

## ğŸ“Š MÃ©tricas del Estado Actual (Baseline)

| MÃ©trica | Valor Actual | Objetivo | GAP |
|---------|---------------------|----------------|-----|
| Time-to-Market | 4 meses | ReducciÃ³n dramÃ¡tica | CrÃ­tico |
| Ventana de Despliegue | 6 horas | 0 (OperaciÃ³n 24/7) | -100% |
| Throughput (TPS) | 2,000 TPS | 1,000,000 TPS | 500x |
| Latencia Fraude | Debe ser < 100ms | < 100ms | Mantener SLA |
| Disponibilidad | Actual con caÃ­das | 99.999% | CrÃ­tico |
| ReconciliaciÃ³n Batch | 6 horas bloqueantes (00:00-06:00 UTC) | Tiempo real | CrÃ­tico |

---

## ğŸ” Insights Clave del Domain Storytelling

### 1. Dependencias CrÃ­ticas
- **Base de Datos Oracle Centralizada**: Cuello de botella Ãºnico (SPOF)
- **PL/SQL**: 40% de la lÃ³gica de negocio atrapada en stored procedures
- **Secuencias Globales**: GeneraciÃ³n de IDs Ãºnicos centralizada impide escalado distribuido
- **Shared Database**: Sistemas satÃ©lites acceden directo a CORE_SCHEMA sin APIs
- **Conexiones Stateful**: Protocolo ISO 8583 sobre TCP dificulta escalado horizontal
- **HSM FÃ­sico On-Premise**: Llaves criptogrÃ¡ficas en hardware fÃ­sico dificultan Cloud
- **Bloqueos de Base de Datos**: Imposibilidad de escalar mÃ³dulos individualmente

### 2. Brechas de Visibilidad
- Los clientes no tienen visibilidad del estado de transacciones durante el clearing bancario
- El equipo de operaciones recibe mÃºltiples alertas de excepciones en reconciliaciÃ³n sin priorizaciÃ³n automÃ¡tica

### 3. MÃºltiples Ventanas de Batch (Problema Compuesto)
El sistema actual tiene **dos ventanas de mantenimiento nocturnas independientes**:

**A. ReconciliaciÃ³n Bancaria (00:00-06:00 UTC)**
- PropÃ³sito: Cruzar extractos de bancos corresponsales vs Ledger interno
- DuraciÃ³n: 6 horas bloqueantes
- Impacto: BD en modo READ-ONLY, operaciones suspendidas

**B. Ventana de Cierre y Batch General (02:00-04:00 AM)**
- PropÃ³sito: Procesos de cierre contable y conciliaciÃ³n masiva del sistema
- DuraciÃ³n: 2 horas
- Impacto: Sistema apagado o bloqueado (Read-Only)

**ImplicaciÃ³n**: Hay solapamiento (02:00-04:00 AM) donde ambos procesos corren simultÃ¡neamente, agravando el bloqueo del sistema. La arquitectura objetivo debe eliminar ambas ventanas para operaciÃ³n 24/7.

### 4. Oportunidades de AutomatizaciÃ³n y ModernizaciÃ³n
- **ReconciliaciÃ³n**: Continua en lugar de batch bloqueante de 6 horas
- **Notificaciones**: Event-driven en lugar de sÃ­ncronas bloqueantes
- **Escalado**: MÃ³dulos independientes (Fraude, Pagos, Ledger) vs monolito Ãºnico
- **Estado de SesiÃ³n**: Externalizar a Redis/Hazelcast en lugar de Sticky Sessions
- **GeneraciÃ³n de IDs**: UUIDs distribuidos en lugar de secuencias Oracle centralizadas
- **IntegraciÃ³n**: APIs REST/gRPC en lugar de Shared Database
- **Despliegue**: Microservicios independientes en lugar de God Classes monolÃ­ticas

---


**PrÃ³ximos Pasos:**
- â†’ Ir a `1.2-Drivers-Arquitectura.md` para traducir estos dolores en drivers formales
- â†’ Identificar Business Capabilities a transformar en `1.3-Business-Capabilities.md`

---

**Ãšltima actualizaciÃ³n**: 13 de diciembre de 2025
